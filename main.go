package main

import (
	"database/sql"
	"encoding/xml"
	"flag"
	"fmt"
	"io/ioutil"
	"net/http"
	"regexp"
	"strconv"
	"strings"
	"time"

	_ "github.com/lib/pq" //postgreSQLのドライバ読み込みたいだけ
	"gopkg.in/cheggaaa/pb.v1"
)

// VuldefDoc VuldefDoc要素
type VuldefDoc struct {
	VuldefDoc string    `xml:"VULDEF-Document"`
	Vulinfoes []Vulinfo `xml:"Vulinfo"`
}

// Vulinfo Vulinfo要素
type Vulinfo struct {
	VulinfoID   string      `xml:"VulinfoID"`
	VulinfoData VulinfoData `xml:"VulinfoData"`
}

// VulinfoData VulinfoData要素
type VulinfoData struct {
	Title           string   `xml:"Title"`
	Affected        Affected `xml:"Affected"`
	Impact          Impact   `xml:"Impact"`
	Solution        Solution `xml:"Solution"`
	Related         Related  `xml:"Related"`
	DateLastUpdated string   `xml:"DateLastUpdated"`
}

// Affected Affected要素
type Affected struct {
	AffectedItem []AffectedItem `xml:"AffectedItem"`
}

// AffectedItem AffectedItem要素
type AffectedItem struct {
	Name        string `xml:"Name"`
	ProductName string `xml:"ProductName"`
	Version     string `xml:"VersionNumber"`
}

// Impact Impact要素
type Impact struct {
	Cvss       []Cvss     `xml:"Cvss"`
	ImpactItem ImpactItem `xml:"ImpactItem"`
}

// Cvss Cvss要素
type Cvss struct {
	SeverityType string  `xml:"Severity"`
	Base         float64 `xml:"Base"`
}

// ImpactItem ImpactItem要素
type ImpactItem struct {
	Description string `xml:"Description"`
}

// Solution Solution要素
type Solution struct {
	SolutionItem SolutionItem `xml:"SolutionItem"`
}

// SolutionItem SolutionItem要素
type SolutionItem struct {
	Description string `xml:"Description"`
}

// Related Related要素
type Related struct {
	RelatedItem []RelatedItem `xml:"RelatedItem"`
}

// RelatedItem RelatedItem要素
type RelatedItem struct {
	Name      string `xml:"Name"`
	VulinfoID string `xml:"VulinfoID"`
	URL       string `xml:"URL"`
}

var (
	db   *sql.DB
	host = flag.String("host", "127.0.0.1", "postgres install hostname")
	port = flag.Int("port", 5432, "postgres port")
	user = flag.String("user", "postgres", "postgres login user")
	pass = flag.String("pass", "password", "postgres login password")
	year = flag.Int("year", 2018, "acquire from specified years")
)

// DB接続初期化
func init() {
	var dbError error
	flag.Parse()
	p := strconv.Itoa(*port)
	db, dbError = sql.Open("postgres", "host="+*host+" port="+p+" user="+*user+" password="+*pass+" dbname=vulnerabilityInfo sslmode=disable")
	if dbError != nil {
		fmt.Println("DB connect error: ", dbError)
		return
	}
}

func main() {
	var y int
	flag.Parse()
	now := time.Now()
	todayYear := now.Year()
	if *year < 2016 {
		y = 2016
	} else {
		y = *year
	}
	for y <= todayYear {
		var i int
		yS := strconv.Itoa(y)
		getURL := "https://jvndb.jvn.jp/ja/feed/detail/jvndb_detail_" + yS + ".rdf"
		fmt.Println("****    will get the vulnerability information of " + yS)
		xmlData := getXML(getURL)
		data := new(VuldefDoc)
		xmlError := xml.Unmarshal([]byte(xmlData), &data)
		if xmlError != nil {
			fmt.Println("XML read error: ", xmlError)
			return
		}
		vulinfoNum := len(data.Vulinfoes)
		bar := pb.StartNew(vulinfoNum)
		for i < vulinfoNum {
			registResult := getVulinfo(i, data)
			if !registResult {
				fmt.Println("Data Regist Error")
			}
			bar.Increment()
			i++
		}
		bar.FinishPrint("****    have finished get the vulnerability information of " + yS)
		y++
	}
}

func registVendorInfo(vendorName string) bool {
	var count int
	countQuery := "select count(*) from vendorinfo where vendorName = ($1)"

	countRow := db.QueryRow(countQuery, vendorName)
	countError := countRow.Scan(&count)
	if countError != nil {
		fmt.Println("Vendor Count Error:", countError)
		return false
	}
	if count == 0 {
		vendorQuery := "insert into vendorinfo (vendorName) values ($1)"
		_, queryError := db.Exec(vendorQuery, vendorName)
		if queryError != nil {
			fmt.Println("vendor query error: ", queryError)
			return false
		}
	}
	return true
}

func registProductInfo(vendorName, productName string) bool {
	var count, id int
	countQuery := "select count(*) from productinfo where productname = ($1)"

	countRow := db.QueryRow(countQuery, productName)
	countError := countRow.Scan(&count)
	if countError != nil {
		fmt.Println("Product Count Error:", countError)
		return false
	}
	if count == 0 {
		vendorQuery := "select id from vendorinfo where vendorName = ($1)"

		vendorRow := db.QueryRow(vendorQuery, vendorName)
		vendorError := vendorRow.Scan(&id)
		if vendorError != nil {
			fmt.Println("Vendor Select Error:", vendorError)
			return false
		}
		productQuery := "insert into productinfo (productname,vendorid) values ($1,$2)"
		_, queryError := db.Exec(productQuery, productName, id)
		if queryError != nil {
			fmt.Println("Product query error: ", queryError)
			return false
		}
	}
	return true
}

func registVulProduct(vulinfoID, productName string) bool {
	var count, pid int
	productQuery := "select id from productinfo where productname = ($1)"

	productRow := db.QueryRow(productQuery, productName)
	productError := productRow.Scan(&pid)
	if productError != nil {
		fmt.Println("Product Select Error:", productError)
		return false
	}
	countQuery := "select count(*) from vulproduct where vulinfoid = ($1) and productid = ($2)"
	countRow := db.QueryRow(countQuery, vulinfoID, pid)
	countError := countRow.Scan(&count)
	if countError != nil {
		fmt.Println("Product Count Error:", countError)
		return false
	}
	if count == 0 {
		vulProductQuery := "insert into vulproduct (vulinfoid,productid) values ($1,$2)"
		_, queryError := db.Exec(vulProductQuery, vulinfoID, pid)
		if queryError != nil {
			fmt.Println("VulProduct query error: ", queryError)
			return false
		}
	}
	return true
}

func registCve(vulinfoID, cve string) bool {
	var count int
	countQuery := "select count(*) from cve where cve = ($1) and vulinfoid = ($2)"
	countRow := db.QueryRow(countQuery, cve, vulinfoID)
	countError := countRow.Scan(&count)
	if countError != nil {
		fmt.Println("CVE Count Error:", countError)
		return false
	}
	if count == 0 {
		cveQuery := "insert into cve (cve,vulinfoid) values ($1,$2)"
		_, queryError := db.Exec(cveQuery, cve, vulinfoID)
		if queryError != nil {
			fmt.Println("CVE query error: ", queryError)
			return false
		}
	}
	return true
}

func registVulInfo(vulinfoID, title, severityTypeV3, impactDescription, solutionDescription, dateLastUpdated string, baseV3 float64) bool {
	var count int
	var update string
	countQuery := "select count(*) from vulinfo where vulinfoid = ($1)"
	countRow := db.QueryRow(countQuery, vulinfoID)
	countError := countRow.Scan(&count)
	if countError != nil {
		fmt.Println("VulInfo Count Error:", countError)
		return false
	}
	if count == 0 {
		cveQuery := "insert into vulinfo (vulinfoid,title,cvssv3type,cvssv3base,impactdescription,solutiondescription,lastupdate) values ($1,$2,$3,$4,$5,$6,$7)"
		_, queryError := db.Exec(cveQuery, vulinfoID, title, severityTypeV3, baseV3, impactDescription, solutionDescription, dateLastUpdated)
		if queryError != nil {
			fmt.Println("VulInfo query error: ", queryError)
			return false
		}
	} else if count == 1 {
		dateQuery := "select lastupdate from vulinfo where vulinfoid = ($1)"

		dateRow := db.QueryRow(dateQuery, vulinfoID)
		dateError := dateRow.Scan(&update)
		if dateError != nil {
			fmt.Println("update Select Error:", dateError)
			return false
		}
		if update != dateLastUpdated {
			updateQuery := "update vulinfo set title = ($2),cvssv3type=($3),cvssv3base=($4),impactdescription=($5),solutiondescription=($6),lastupdate=($7) where vulinfoid = ($1)"
			_, queryError := db.Exec(updateQuery, vulinfoID, title, severityTypeV3, baseV3, impactDescription, solutionDescription, dateLastUpdated)
			if queryError != nil {
				fmt.Println("Update query error: ", queryError)
				return false
			}
		}
	}
	return true
}

func getVulinfo(vulinfoNum int, data *VuldefDoc) bool {
	var severityTypeV3, relatedVulinfoID string
	var baseV3 float64
	var i, j int
	vulinfoID := data.Vulinfoes[vulinfoNum].VulinfoID
	title := data.Vulinfoes[vulinfoNum].VulinfoData.Title
	affectedItemNum := len(data.Vulinfoes[vulinfoNum].VulinfoData.Affected.AffectedItem)
	for j < affectedItemNum {
		vendorName := data.Vulinfoes[vulinfoNum].VulinfoData.Affected.AffectedItem[j].Name
		vendorInfoError := registVendorInfo(vendorName)
		if !vendorInfoError {
			fmt.Println("vendorInfo error")
			return false
		}
		productName := data.Vulinfoes[vulinfoNum].VulinfoData.Affected.AffectedItem[j].ProductName
		productInfoError := registProductInfo(vendorName, productName)
		if !productInfoError {
			fmt.Println("productInfo error")
			return false
		}
		vulProductError := registVulProduct(vulinfoID, productName)
		if !vulProductError {
			fmt.Println("vulProduct error")
			return false
		}
		j++
	}
	cvssNum := len(data.Vulinfoes[vulinfoNum].VulinfoData.Impact.Cvss)
	if cvssNum == 2 {
		severityTypeV3 = data.Vulinfoes[vulinfoNum].VulinfoData.Impact.Cvss[1].SeverityType
		baseV3 = data.Vulinfoes[vulinfoNum].VulinfoData.Impact.Cvss[1].Base
	} else if cvssNum == 1 {
		severityTypeV3 = data.Vulinfoes[vulinfoNum].VulinfoData.Impact.Cvss[0].SeverityType
		baseV3 = data.Vulinfoes[vulinfoNum].VulinfoData.Impact.Cvss[0].Base
	}
	impactItemDescription := data.Vulinfoes[vulinfoNum].VulinfoData.Impact.ImpactItem.Description
	solutionItemDescription := data.Vulinfoes[vulinfoNum].VulinfoData.Solution.SolutionItem.Description
	relatedNum := len(data.Vulinfoes[vulinfoNum].VulinfoData.Related.RelatedItem)
	for i < relatedNum {
		relatedVulinfoID = data.Vulinfoes[vulinfoNum].VulinfoData.Related.RelatedItem[i].VulinfoID
		if strings.Contains(relatedVulinfoID, "CVE") {
			r := regexp.MustCompile(`[CVE\-\d\-]+`)
			cveList := r.FindAllStringSubmatch(relatedVulinfoID, -1)
			cveError := registCve(vulinfoID, cveList[0][0])
			if !cveError {
				fmt.Println("CVE error")
				return false
			}
		}
		i++
	}
	dateLastUpdated := data.Vulinfoes[vulinfoNum].VulinfoData.DateLastUpdated
	r := regexp.MustCompile(`[\d\-]+`)
	dateLastUpdatedList := r.FindAllStringSubmatch(dateLastUpdated, -1)
	vulInfoError := registVulInfo(vulinfoID, title, severityTypeV3, impactItemDescription, solutionItemDescription, dateLastUpdatedList[0][0], baseV3)
	if !vulInfoError {
		fmt.Println("VulInfo error")
		return false
	}
	return true
}

func getXML(url string) string {
	response, _ := http.Get(url)
	body, _ := ioutil.ReadAll(response.Body)
	defer response.Body.Close()
	return string(body)
}
